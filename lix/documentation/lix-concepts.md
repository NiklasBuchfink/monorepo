## how does merge work
lix is supposed to be out of your way, not introduce unneeded concepts and work seamlessly for binary, text and strucutred text based files alike. Git conflict markers and git conflict repo states with semi-locked flow is a constant cause of pain, also reflected in the design of other vsc systems like jj and couchdb, where conflicts do not block activity but can be resolved with generic file based tools at a time convenient to the user and / or application layer!

lix will behave in all underlying git operations as if no conflict exsisted, always picking a predictable version as winning revision, similar to couchdb. alternate versions will be added to conflict markers with a file suffix .<commit hash>.conflict. the repo status api will report files with conflicts similar to modified files in a dirty workdir to inform the commit actions of this fact but its up to the user/ application to decide to commit conflict markers as regular files and delay resolution to be done in a seperate system/ later time. this has many advantages: workflows are not interrupted especially painful for things like rebase. conflict markers will not destroy syntax/ tooling making it much easier to compare and act on conflicts. tools can decide to handle any number of conflicts at the same time. if conflicts are caused by formatting tools such as prettier, you can format all the conflicting versions first and then run resolution on the resulting files which removes all but the real conflicts saving tons of headaches. this works for any file type not just text files leading to much more unified workflows.

## how does staging work
lix does not have a concept of staging but treats this as an implementation detail of the underlying git repo. a commit unless triggered with include/exclude options will always commit the current workdir state